var g=Symbol("NOT_FOUND");function z(e,n=`expected a function, instead received ${typeof e}`){if(typeof e!="function")throw new TypeError(n)}function T(e,n=`expected an object, instead received ${typeof e}`){if(typeof e!="object")throw new TypeError(n)}function j(e,n="expected all items to be functions, instead received the following types: "){if(!e.every(t=>typeof t=="function")){const t=e.map(o=>typeof o=="function"?`function ${o.name||"unnamed"}()`:typeof o).join(", ");throw new TypeError(`${n}[${t}]`)}}var C=e=>Array.isArray(e)?e:[e];function M(e){const n=Array.isArray(e[0])?e[0]:e;return j(n,"createSelector expects all input-selectors to be functions, but received the following types: "),n}function I(e,n){const t=[],{length:o}=e;for(let i=0;i<o;i++)t.push(e[i].apply(null,n));return t}function x(e){let n;return{get(t){return n&&e(n.key,t)?n.value:g},put(t,o){n={key:t,value:o}},getEntries(){return n?[n]:[]},clear(){n=void 0}}}function O(e,n){let t=[];function o(r){const l=t.findIndex(c=>n(r,c.key));if(l>-1){const c=t[l];return l>0&&(t.splice(l,1),t.unshift(c)),c.value}return g}function i(r,l){o(r)===g&&(t.unshift({key:r,value:l}),t.length>e&&t.pop())}function s(){return t}function a(){t=[]}return{get:o,put:i,getEntries:s,clear:a}}var $=(e,n)=>e===n;function A(e){return function(t,o){if(t===null||o===null||t.length!==o.length)return!1;const{length:i}=t;for(let s=0;s<i;s++)if(!e(t[s],o[s]))return!1;return!0}}function _(e,n){const t=typeof n=="object"?n:{equalityCheck:n},{equalityCheck:o=$,maxSize:i=1,resultEqualityCheck:s}=t,a=A(o);let r=0;const l=i<=1?x(a):O(i,a);function c(){let u=l.get(arguments);if(u===g){if(u=e.apply(null,arguments),r++,s){const y=l.getEntries().find(f=>s(f.value,u));y&&(u=y.value,r!==0&&r--)}l.put(arguments,u)}return u}return c.clearCache=()=>{l.clear(),c.resetResultsCount()},c.resultsCount=()=>r,c.resetResultsCount=()=>{r=0},c}var D=class{constructor(e){this.value=e}deref(){return this.value}},F=typeof WeakRef<"u"?WeakRef:D,W=0,b=1;function h(){return{s:W,v:void 0,o:null,p:null}}function w(e,n={}){let t=h();const{resultEqualityCheck:o}=n;let i,s=0;function a(){let r=t;const{length:l}=arguments;for(let p=0,y=l;p<y;p++){const f=arguments[p];if(typeof f=="function"||typeof f=="object"&&f!==null){let d=r.o;d===null&&(r.o=d=new WeakMap);const m=d.get(f);m===void 0?(r=h(),d.set(f,r)):r=m}else{let d=r.p;d===null&&(r.p=d=new Map);const m=d.get(f);m===void 0?(r=h(),d.set(f,r)):r=m}}const c=r;let u;if(r.s===b)u=r.v;else if(u=e.apply(null,arguments),s++,o){const p=i?.deref?.()??i;p!=null&&o(p,u)&&(u=p,s!==0&&s--),i=typeof u=="object"&&u!==null||typeof u=="function"?new F(u):u}return c.s=b,c.v=u,u}return a.clearCache=()=>{t=h(),a.resetResultsCount()},a.resultsCount=()=>s,a.resetResultsCount=()=>{s=0},a}function q(e,...n){const t=typeof e=="function"?{memoize:e,memoizeOptions:n}:e,o=(...i)=>{let s=0,a=0,r,l={},c=i.pop();typeof c=="object"&&(l=c,c=i.pop()),z(c,`createSelector expects an output function after the inputs, but received: [${typeof c}]`);const u={...t,...l},{memoize:p,memoizeOptions:y=[],argsMemoize:f=w,argsMemoizeOptions:d=[]}=u,m=C(y),E=C(d),v=M(i),R=p(function(){return s++,c.apply(null,arguments)},...m),S=f(function(){a++;const k=I(v,arguments);return r=R.apply(null,k),r},...E);return Object.assign(S,{resultFunc:c,memoizedResultFunc:R,dependencies:v,dependencyRecomputations:()=>a,resetDependencyRecomputations:()=>{a=0},lastResult:()=>r,recomputations:()=>s,resetRecomputations:()=>{s=0},memoize:p,argsMemoize:f})};return Object.assign(o,{withTypes:()=>o}),o}var U=q(w),K=Object.assign((e,n=U)=>{T(e,`createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof e}`);const t=Object.keys(e),o=t.map(s=>e[s]);return n(o,(...s)=>s.reduce((a,r,l)=>(a[t[l]]=r,a),{}))},{withTypes:()=>K});export{U as a,q as c,_ as l,w};
